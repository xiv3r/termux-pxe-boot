"""
PXE Server for Termux - Arch Linux Boot Server
Handles DHCP, TFTP, and PXE boot configuration without root privileges
"""
import socket
import threading
import struct
import os
import subprocess
import time
import ipaddress
from datetime import datetime

class PXEServer:
    def __init__(self, settings, logger, network_manager):
        self.settings = settings
        self.logger = logger
        self.network_manager = network_manager
        
        # Server configuration
        self.is_running = False
        self.dhcp_socket = None
        self.tftp_socket = None
        self.threads = []
        
        # Network configuration
        self.server_ip = "192.168.1.100"
        self.network = "192.168.1.0/24"
        self.dhcp_range_start = "192.168.1.50"
        self.dhcp_range_end = "192.168.1.200"
        
        # Boot files
        self.boot_dir = "/data/data/com.termux/files/home/pxe_boot"
        self.tftp_dir = "/data/data/com.termux/files/home/pxe_tftp"
        self.assets_dir = "/data/data/com.termux/files/home/pxe_assets"
        
        # Create directories
        self._create_directories()
        
    def _create_directories(self):
        """Create necessary directories for PXE boot"""
        dirs = [self.boot_dir, self.tftp_dir, self.assets_dir]
        for directory in dirs:
            os.makedirs(directory, exist_ok=True)
            self.logger.info(f"Created directory: {directory}")
            
    def prepare_boot_files(self):
        """Prepare boot files and Arch Linux installation"""
        try:
            self.logger.info("Preparing boot files...")
            
            # Download/extract Arch Linux bootstrap
            if not self._download_arch_bootstrap():
                return False
                
            # Create PXE boot configuration
            if not self._create_pxe_config():
                return False
                
            # Setup boot menu
            if not self._create_boot_menu():
                return False
                
            # Create installation scripts
            if not self._create_installation_scripts():
                return False
                
            self.logger.info("Boot files prepared successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to prepare boot files: {e}")
            return False
            
    def _download_arch_bootstrap(self):
        """Download Arch Linux bootstrap files"""
        try:
            arch_dir = os.path.join(self.assets_dir, "arch")
            os.makedirs(arch_dir, exist_ok=True)
            
            # Note: In a real implementation, this would download actual Arch Linux files
            # For now, we'll create placeholder structure
            
            # Create basic directory structure
            directories = [
                "boot",
                "boot/syslinux",
                "boot/grub",
                "root",
                "etc",
                "usr/bin",
                "usr/lib",
                "var/cache/pacman"
            ]
            
            for directory in directories:
                os.makedirs(os.path.join(arch_dir, directory), exist_ok=True)
                
            # Create placeholder files
            placeholder_files = {
                "boot/vmlinuz": "# Arch Linux Kernel Placeholder",
                "boot/initramfs.img": "# Arch Linux Initramfs Placeholder",
                "boot/syslinux/ldlinux.c32": "# Syslinux bootloader",
                "boot/syslinux/pxelinux.0": "# PXELinux bootloader",
                "root/.bashrc": "# Custom bashrc with Kali-like settings"
            }
            
            for file_path, content in placeholder_files.items():
                full_path = os.path.join(arch_dir, file_path)
                with open(full_path, 'w') as f:
                    f.write(content)
                    
            self.logger.info("Arch bootstrap structure created")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to create bootstrap: {e}")
            return False
            
    def _create_pxe_config(self):
        """Create PXE configuration files"""
        try:
            # Create dhcpd.conf
            dhcp_config = f"""
# PXE DHCP Configuration
# Generated by Termux PXE Boot

default-lease-time 600;
max-lease-time 7200;
authoritative;

# Network configuration
subnet {self.network} netmask 255.255.255.0 {{
    range {self.dhcp_range_start} {self.dhcp_range_end};
    option routers {self.server_ip};
    option domain-name-servers {self.server_ip};
    option domain-name "pxe.local";
    
    # PXE specific options
    next-server {self.server_ip};
    filename "pxelinux.0";
    
    # Boot menu
    option bootfile-name "pxelinux.0";
}}
            """
            
            dhcp_conf_path = os.path.join(self.boot_dir, "dhcpd.conf")
            with open(dhcp_conf_path, 'w') as f:
                f.write(dhcp_config)
                
            self.logger.info("DHCP configuration created")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to create PXE config: {e}")
            return False
            
    def _create_boot_menu(self):
        """Create PXE boot menu"""
        try:
            # Create pxelinux.cfg/default
            menu_config = """
# PXELinux Configuration
# Generated by Termux PXE Boot

DEFAULT menu.c32
PROMPT 0
MENU TITLE Arch Linux PXE Boot - Enhanced Performance Edition

MENU BACKGROUND
MENU WIDTH 80
MENU MARGIN 10
MENU PASSWORDMARGIN 3
MENU ROWS 12
MENU TABMSGROW 18
MENU CMDLINEROW 18
MENU ENDROW 24
MENU PASSWORDROW 11
MENU TIMEOUTROW 20

# Menu Colors
MENUCOLOR TITLE    1;36;44    #c0ffffff #00000000 none
MENUCOLOR SEL      7;37;40    #ffffffff #e0000000 none
MENUCOLOR HOTSEL   1;37;40    #ffffffff #e0000000 none
MENUCOLOR HOTKEY   2;34;44    #c0ffffff #00000000 std
MENUCOLOR HELP     2;36;44    #c0ffffff #00000000 std
MENUCOLOR GMSAUTH  1;36;44    #c0ffffff #00000000 none
MENUCOLOR AUTH     1;36;44    #c0ffffff #00000000 none
MENUCOLOR SELMSG   1;36;44    #c0ffffff #00000000 none

LABEL Arch Linux - Kali Edition (Maximum Performance)
    MENU DEFAULT
    KERNEL arch/vmlinuz
    APPEND initrd=arch/initramfs.img root=/dev/ram0 ramdisk_size=2097152 quiet splash

LABEL Arch Linux - Live Boot (Safe Mode)
    MENU LABEL Arch Linux - Live Boot (Safe Mode)
    KERNEL arch/vmlinuz
    APPEND initrd=arch/initramfs.img root=/dev/ram0 ramdisk_size=2097152 noapic noacpi

LABEL Network Install
    MENU LABEL Network Installation
    KERNEL arch/vmlinuz
    APPEND initrd=arch/initramfs.img root=/dev/ram0 ramdisk_size=2097152

LABEL Arch Linux - Minimal (Custom)
    MENU LABEL Minimal Installation
    KERNEL arch/vmlinuz
    APPEND initrd=arch/initramfs.img root=/dev/ram0 ramdisk_size=2097152 minimal
            """
            
            pxelinux_cfg_dir = os.path.join(self.tftp_dir, "pxelinux.cfg")
            os.makedirs(pxelinux_cfg_dir, exist_ok=True)
            
            menu_path = os.path.join(pxelinux_cfg_dir, "default")
            with open(menu_path, 'w') as f:
                f.write(menu_config)
                
            # Copy menu.c32 if available (placeholder)
            menu_c32_path = os.path.join(self.tftp_dir, "menu.c32")
            with open(menu_c32_path, 'wb') as f:
                f.write(b"# Placeholder for menu.c32")
                
            self.logger.info("Boot menu created")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to create boot menu: {e}")
            return False
            
    def _create_installation_scripts(self):
        """Create Arch Linux installation and post-install scripts"""
        try:
            scripts_dir = os.path.join(self.assets_dir, "scripts")
            os.makedirs(scripts_dir, exist_ok=True)
            
            # Post-install script with Kali-like customization
            post_install_script = """#!/bin/bash
# Arch Linux Post-Install Script - Kali-like Customization
# Generated by Termux PXE Boot

set -e

echo "Starting Arch Linux Installation with Kali-like Customization"

# Update system
pacman -Sy --noconfirm

# Install base packages
pacman -S --noconfirm base base-devel

# Install Xorg and desktop environment
pacman -S --noconfirm xorg-server xorg-xinit

# Install Kali-style theming
pacman -S --noconfirm numix-gtk-theme numix-icon-theme

# Install performance tools
pacman -S --noconfirm preload tuned cpupower

# Install development tools
pacman -S --noconfirm vim nano htop

# Configure network
systemctl enable NetworkManager
systemctl start NetworkManager

# Install custom shell
pacman -S --noconfirm zsh
chsh -s /bin/zsh

# Create custom user
useradd -m -G wheel -s /bin/zsh user
echo "user:password" | chpasswd

# Configure sudo
echo "%wheel ALL=(ALL) ALL" >> /etc/sudoers

# Set up Kali-like aliases
cat >> /root/.bashrc << 'EOF'
alias ls='ls --color=auto'
alias ll='ls -la --color=auto'
alias grep='grep --color=auto'
alias alert='notify-send -u normal "$(history|tail -n1|sed -e "s/^\\s*[0-9]\\+\\s*//;s/[;&|]\\s*$//")"'
alias ..='cd ..'
alias ...='cd ../..'
alias restart='sudo reboot'
alias shutdown='sudo poweroff'
alias kali-update='sudo pacman -Syu'
alias kali-upgrade='sudo pacman -Syyu'
alias kali-clean='sudo pacman -Scc'
alias kali-install='sudo pacman -S'
alias kali-remove='sudo pacman -Rns'
EOF

# Performance optimizations
echo 'vm.swappiness=10' >> /etc/sysctl.conf
echo 'vm.vfs_cache_pressure=50' >> /etc/sysctl.conf
echo 'kernel.sched_migration_cost_ns=5000000' >> /etc/sysctl.conf

# Set up custom motd
cat > /etc/motd << 'EOF'
============================================================
               Arch Linux Enhanced Edition              
            Powered by Termux PXE Boot System           
          Optimized for Maximum Performance             
============================================================
Welcome to your custom Arch Linux installation!
Type 'kali-help' for available commands.
EOF

echo "Installation completed successfully!"
echo "System optimized for maximum performance"
echo "Kali-like customization applied"
echo ""
echo "Rebooting in 10 seconds..."
sleep 10
reboot
            """
            
            script_path = os.path.join(scripts_dir, "post-install.sh")
            with open(script_path, 'w') as f:
                f.write(post_install_script)
                
            # Make script executable
            os.chmod(script_path, 0o755)
            
            self.logger.info("Installation scripts created")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to create installation scripts: {e}")
            return False
            
    def start(self):
        """Start the PXE server"""
        try:
            if self.is_running:
                self.logger.warning("PXE server is already running")
                return
                
            self.is_running = True
            self.logger.info("Starting PXE server...")
            
            # Start TFTP server
            tftp_thread = threading.Thread(target=self._run_tftp_server, daemon=True)
            tftp_thread.start()
            self.threads.append(tftp_thread)
            
            # Start DHCP server
            dhcp_thread = threading.Thread(target=self._run_dhcp_server, daemon=True)
            dhcp_thread.start()
            self.threads.append(dhcp_thread)
            
            # Start monitoring thread
            monitor_thread = threading.Thread(target=self._monitor_server, daemon=True)
            monitor_thread.start()
            self.threads.append(monitor_thread)
            
            self.logger.info("PXE server started successfully")
            
        except Exception as e:
            self.logger.error(f"Failed to start PXE server: {e}")
            self.is_running = False
            raise
            
    def stop(self):
        """Stop the PXE server"""
        try:
            self.is_running = False
            
            # Close sockets
            if self.dhcp_socket:
                self.dhcp_socket.close()
            if self.tftp_socket:
                self.tftp_socket.close()
                
            # Wait for threads to finish
            for thread in self.threads:
                if thread.is_alive():
                    thread.join(timeout=2)
                    
            self.logger.info("PXE server stopped")
            
        except Exception as e:
            self.logger.error(f"Error stopping PXE server: {e}")
            
    def _run_tftp_server(self):
        """Run TFTP server for file transfers"""
        try:
            # Try to use external tftpd if available
            tftpd_commands = [
                "tftpd -l -s {}/".format(self.tftp_dir),
                "atftpd --daemon --port 69 --logfile /dev/stdout {}".format(self.tftp_dir)
            ]
            
            for cmd in tftpd_commands:
                try:
                    result = subprocess.run(cmd.split(), capture_output=True, timeout=5)
                    if result.returncode == 0:
                        self.logger.info(f"TFTP server started: {cmd}")
                        break
                except:
                    continue
            
            # If no external server available, create simple TFTP server
            self._create_simple_tftp_server()
            
        except Exception as e:
            self.logger.error(f"TFTP server error: {e}")
            
    def _create_simple_tftp_server(self):
        """Create a simple TFTP server using Python"""
        try:
            self.tftp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.tftp_socket.bind(('0.0.0.0', 69))
            
            self.logger.info("Simple TFTP server started on port 69")
            
            while self.is_running:
                try:
                    data, addr = self.tftp_socket.recvfrom(1024)
                    self._handle_tftp_request(data, addr)
                except socket.timeout:
                    continue
                except Exception as e:
                    if self.is_running:
                        self.logger.error(f"TFTP error: {e}")
                    break
                    
        except Exception as e:
            self.logger.error(f"Simple TFTP server error: {e}")
            
    def _handle_tftp_request(self, data, addr):
        """Handle TFTP request"""
        try:
            # Simple TFTP implementation
            if len(data) < 4:
                return
                
            opcode = struct.unpack('!H', data[:2])[0]
            filename = data[2:].split(b'\x00')[0].decode('utf-8')
            
            if opcode == 1:  # Read request
                self._send_tftp_file(filename, addr)
            elif opcode == 2:  # Write request
                # Not implemented for security
                pass
                
        except Exception as e:
            self.logger.error(f"TFTP request handling error: {e}")
            
    def _send_tftp_file(self, filename, addr):
        """Send file via TFTP"""
        try:
            file_path = os.path.join(self.tftp_dir, filename)
            if not os.path.exists(file_path):
                # Try assets directory
                file_path = os.path.join(self.assets_dir, filename)
                
            if os.path.exists(file_path):
                with open(file_path, 'rb') as f:
                    file_data = f.read()
                    
                # Send file in 512-byte blocks
                block_size = 512
                block_num = 1
                offset = 0
                
                while offset < len(file_data):
                    block_data = file_data[offset:offset + block_size]
                    if len(block_data) < block_size:
                        # Last block - send as DATA with special handling
                        pass
                        
                    # Send DATA packet
                    data_packet = struct.pack('!HH', 3, block_num) + block_data
                    self.tftp_socket.sendto(data_packet, addr)
                    
                    offset += block_size
                    block_num += 1
                    
                    # Wait for ACK (simplified)
                    time.sleep(0.01)
                    
        except Exception as e:
            self.logger.error(f"TFTP file send error: {e}")
            
    def _run_dhcp_server(self):
        """Run DHCP server for PXE clients"""
        try:
            # Try to use external dnsmasq or isc-dhcp-server
            dhcp_commands = [
                "dnsmasq -d -p 67 -F {},{} -R -o --log-queries".format(
                    self.dhcp_range_start, self.dhcp_range_end
                ),
                "python3 -c 'import socket; print(\"Simple DHCP would run here\")'"
            ]
            
            for cmd in dhcp_commands:
                try:
                    result = subprocess.run(cmd.split(), capture_output=True, timeout=5)
                    if result.returncode == 0:
                        self.logger.info(f"DHCP server started: {cmd}")
                        break
                except:
                    continue
            
            # If no external server available, create simple DHCP server
            self._create_simple_dhcp_server()
            
        except Exception as e:
            self.logger.error(f"DHCP server error: {e}")
            
    def _create_simple_dhcp_server(self):
        """Create a simple DHCP server using Python"""
        try:
            self.dhcp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.dhcp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.dhcp_socket.bind(('0.0.0.0', 67))
            
            self.logger.info("Simple DHCP server started on port 67")
            
            # Simple DHCP offer generation
            while self.is_running:
                try:
                    data, addr = self.dhcp_socket.recvfrom(1024)
                    self._handle_dhcp_request(data, addr)
                except socket.timeout:
                    continue
                except Exception as e:
                    if self.is_running:
                        self.logger.error(f"DHCP error: {e}")
                    break
                    
        except Exception as e:
            self.logger.error(f"Simple DHCP server error: {e}")
            
    def _handle_dhcp_request(self, data, addr):
        """Handle DHCP request"""
        try:
            # Simple DHCP implementation
            # In a real implementation, this would properly parse DHCP requests
            # and send DHCP offers with PXE boot information
            
            self.logger.info(f"DHCP request from {addr}")
            
            # For demonstration, just log the request
            if len(data) >= 4:
                # Check if it's a DHCP request (boot request)
                message_type = data[4:5]
                if len(message_type) == 1 and ord(message_type) == 1:
                    self.logger.info("DHCP Discover received")
                    
        except Exception as e:
            self.logger.error(f"DHCP request handling error: {e}")
            
    def _monitor_server(self):
        """Monitor server status and handle cleanup"""
        try:
            while self.is_running:
                time.sleep(1)
                
            # Cleanup when server stops
            self._cleanup()
            
        except Exception as e:
            self.logger.error(f"Server monitor error: {e}")
            
    def _cleanup(self):
        """Cleanup server resources"""
        try:
            if self.dhcp_socket:
                self.dhcp_socket.close()
            if self.tftp_socket:
                self.tftp_socket.close()
        except:
            pass
            
    def get_status(self):
        """Get current server status"""
        return {
            'is_running': self.is_running,
            'server_ip': self.server_ip,
            'network': self.network,
            'boot_dir': self.boot_dir,
            'tftp_dir': self.tftp_dir,
            'uptime': time.time() - getattr(self, 'start_time', time.time())
        }
